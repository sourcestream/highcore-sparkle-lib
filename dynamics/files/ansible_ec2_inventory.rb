SparkleFormation.dynamic(:files_ansible_ec2_inventory) do | id, config = {} |

  config[:config_path] ||= '/etc/ansible/ec2.ini'
  config[:script_path] ||= '/etc/ansible/ec2.py'

  set!(config[:config_path]) do
    content join!([
"[ec2]\n",
"regions = ", config[:region], "\n",
"regions_exclude =\n",
"destination_variable = public_dns_name\n",
"vpc_destination_variable = private_dns_name\n",
"route53 = False\n",
"rds = False\n",
"all_instances = False\n",
"all_rds_instances = False\n",
"cache_path = ~/.ansible/tmp\n",
"cache_max_age = 120\n",
"nested_groups = False\n",
"group_by_instance_id = False\n",
"group_by_region = False\n",
"group_by_availability_zone = False\n",
"group_by_ami_id = False\n",
"group_by_instance_type = False\n",
"group_by_key_pair = False\n",
"group_by_vpc_id = False\n",
"group_by_security_group = False\n",
"group_by_tag_keys = True\n",
"group_by_tag_none = False\n",
"group_by_route53_names = False\n",
"group_by_rds_engine = False\n",
"group_by_rds_parameter_group = False\n",
"instance_filters = tag:aws:cloudformation:stack-name=", config[:stack_name], "\n",
                  ])
    mode "000755"
  end

  set!(config[:script_path]) do
    content join!([
"#!/usr/bin/env python\n",
"\n",
"'''\n",
"EC2 external inventory script\n",
"=================================\n",
"\n",
"Generates inventory that Ansible can understand by making API request to\n",
"AWS EC2 using the Boto library.\n",
"\n",
"NOTE: This script assumes Ansible is being executed where the environment\n",
"variables needed for Boto have already been set:\n",
"    export AWS_ACCESS_KEY_ID='AK123'\n",
"    export AWS_SECRET_ACCESS_KEY='abc123'\n",
"\n",
"This script also assumes there is an ec2.ini file alongside it.  To specify a\n",
"different path to ec2.ini, define the EC2_INI_PATH environment variable:\n",
"\n",
"    export EC2_INI_PATH=/path/to/my_ec2.ini\n",
"\n",
"If you're using eucalyptus you need to set the above variables and\n",
"you need to define:\n",
"\n",
"    export EC2_URL=http://hostname_of_your_cc:port/services/Eucalyptus\n",
"\n",
"For more details, see: http://docs.pythonboto.org/en/latest/boto_config_tut.html\n",
"\n",
"When run against a specific host, this script returns the following variables:\n",
" - ec2_ami_launch_index\n",
" - ec2_architecture\n",
" - ec2_association\n",
" - ec2_attachTime\n",
" - ec2_attachment\n",
" - ec2_attachmentId\n",
" - ec2_client_token\n",
" - ec2_deleteOnTermination\n",
" - ec2_description\n",
" - ec2_deviceIndex\n",
" - ec2_dns_name\n",
" - ec2_eventsSet\n",
" - ec2_group_name\n",
" - ec2_hypervisor\n",
" - ec2_id\n",
" - ec2_image_id\n",
" - ec2_instanceState\n",
" - ec2_instance_type\n",
" - ec2_ipOwnerId\n",
" - ec2_ip_address\n",
" - ec2_item\n",
" - ec2_kernel\n",
" - ec2_key_name\n",
" - ec2_launch_time\n",
" - ec2_monitored\n",
" - ec2_monitoring\n",
" - ec2_networkInterfaceId\n",
" - ec2_ownerId\n",
" - ec2_persistent\n",
" - ec2_placement\n",
" - ec2_platform\n",
" - ec2_previous_state\n",
" - ec2_private_dns_name\n",
" - ec2_private_ip_address\n",
" - ec2_publicIp\n",
" - ec2_public_dns_name\n",
" - ec2_ramdisk\n",
" - ec2_reason\n",
" - ec2_region\n",
" - ec2_requester_id\n",
" - ec2_root_device_name\n",
" - ec2_root_device_type\n",
" - ec2_security_group_ids\n",
" - ec2_security_group_names\n",
" - ec2_shutdown_state\n",
" - ec2_sourceDestCheck\n",
" - ec2_spot_instance_request_id\n",
" - ec2_state\n",
" - ec2_state_code\n",
" - ec2_state_reason\n",
" - ec2_status\n",
" - ec2_subnet_id\n",
" - ec2_tenancy\n",
" - ec2_virtualization_type\n",
" - ec2_vpc_id\n",
"\n",
"These variables are pulled out of a boto.ec2.instance object. There is a lack of\n",
"consistency with variable spellings (camelCase and underscores) since this\n",
"just loops through all variables the object exposes. It is preferred to use the\n",
"ones with underscores when multiple exist.\n",
"\n",
"In addition, if an instance has AWS Tags associated with it, each tag is a new\n",
"variable named:\n",
" - ec2_tag_[Key] = [Value]\n",
"\n",
"Security groups are comma-separated in 'ec2_security_group_ids' and\n",
"'ec2_security_group_names'.\n",
"'''\n",
"\n",
"# (c) 2012, Peter Sankauskas\n",
"#\n",
"# This file is part of Ansible,\n",
"#\n",
"# Ansible is free software: you can redistribute it and/or modify\n",
"# it under the terms of the GNU General Public License as published by\n",
"# the Free Software Foundation, either version 3 of the License, or\n",
"# (at your option) any later version.\n",
"#\n",
"# Ansible is distributed in the hope that it will be useful,\n",
"# but WITHOUT ANY WARRANTY; without even the implied warranty of\n",
"# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n",
"# GNU General Public License for more details.\n",
"#\n",
"# You should have received a copy of the GNU General Public License\n",
"# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n",
"\n",
"######################################################################\n",
"\n",
"import sys\n",
"import os\n",
"import argparse\n",
"import re\n",
"from time import time\n",
"import boto\n",
"from boto import ec2\n",
"from boto import rds\n",
"from boto import route53\n",
"import ConfigParser\n",
"from collections import defaultdict\n",
"\n",
"try:\n",
"    import json\n",
"except ImportError:\n",
"    import simplejson as json\n",
"\n",
"\n",
"class Ec2Inventory(object):\n",
"    def _empty_inventory(self):\n",
"        return {\"_meta\" : {\"hostvars\" : {}}}\n",
"\n",
"    def __init__(self):\n",
"        ''' Main execution path '''\n",
"\n",
"        # Inventory grouped by instance IDs, tags, security groups, regions,\n",
"        # and availability zones\n",
"        self.inventory = self._empty_inventory()\n",
"\n",
"        # Index of hostname (address) to instance ID\n",
"        self.index = {}\n",
"\n",
"        # Read settings and parse CLI arguments\n",
"        self.read_settings()\n",
"        self.parse_cli_args()\n",
"\n",
"        # Cache\n",
"        if self.args.refresh_cache:\n",
"            self.do_api_calls_update_cache()\n",
"        elif not self.is_cache_valid():\n",
"            self.do_api_calls_update_cache()\n",
"\n",
"        # Data to print\n",
"        if self.args.host:\n",
"            data_to_print = self.get_host_info()\n",
"\n",
"        elif self.args.list:\n",
"            # Display list of instances for inventory\n",
"            if self.inventory == self._empty_inventory():\n",
"                data_to_print = self.get_inventory_from_cache()\n",
"            else:\n",
"                data_to_print = self.json_format_dict(self.inventory, True)\n",
"\n",
"        print data_to_print\n",
"\n",
"\n",
"    def is_cache_valid(self):\n",
"        ''' Determines if the cache files have expired, or if it is still valid '''\n",
"\n",
"        if os.path.isfile(self.cache_path_cache):\n",
"            mod_time = os.path.getmtime(self.cache_path_cache)\n",
"            current_time = time()\n",
"            if (mod_time + self.cache_max_age) > current_time:\n",
"                if os.path.isfile(self.cache_path_index):\n",
"                    return True\n",
"\n",
"        return False\n",
"\n",
"\n",
"    def read_settings(self):\n",
"        ''' Reads the settings from the ec2.ini file '''\n",
"\n",
"        config = ConfigParser.SafeConfigParser()\n",
"        ec2_default_ini_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'ec2.ini')\n",
"        ec2_ini_path = os.environ.get('EC2_INI_PATH', ec2_default_ini_path)\n",
"        config.read(ec2_ini_path)\n",
"\n",
"        # is eucalyptus?\n",
"        self.eucalyptus_host = None\n",
"        self.eucalyptus = False\n",
"        if config.has_option('ec2', 'eucalyptus'):\n",
"            self.eucalyptus = config.getboolean('ec2', 'eucalyptus')\n",
"        if self.eucalyptus and config.has_option('ec2', 'eucalyptus_host'):\n",
"            self.eucalyptus_host = config.get('ec2', 'eucalyptus_host')\n",
"\n",
"        # Regions\n",
"        self.regions = []\n",
"        configRegions = config.get('ec2', 'regions')\n",
"        configRegions_exclude = config.get('ec2', 'regions_exclude')\n",
"        if (configRegions == 'all'):\n",
"            if self.eucalyptus_host:\n",
"                self.regions.append(boto.connect_euca(host=self.eucalyptus_host).region.name)\n",
"            else:\n",
"                for regionInfo in ec2.regions():\n",
"                    if regionInfo.name not in configRegions_exclude:\n",
"                        self.regions.append(regionInfo.name)\n",
"        else:\n",
"            self.regions = configRegions.split(\",\")\n",
"\n",
"        # Destination addresses\n",
"        self.destination_variable = config.get('ec2', 'destination_variable')\n",
"        self.vpc_destination_variable = config.get('ec2', 'vpc_destination_variable')\n",
"\n",
"        # Route53\n",
"        self.route53_enabled = config.getboolean('ec2', 'route53')\n",
"        self.route53_excluded_zones = []\n",
"        if config.has_option('ec2', 'route53_excluded_zones'):\n",
"            self.route53_excluded_zones.extend(\n",
"                config.get('ec2', 'route53_excluded_zones', '').split(','))\n",
"\n",
"        # Include RDS instances?\n",
"        self.rds_enabled = True\n",
"        if config.has_option('ec2', 'rds'):\n",
"            self.rds_enabled = config.getboolean('ec2', 'rds')\n",
"\n",
"        # Return all EC2 and RDS instances (if RDS is enabled)\n",
"        if config.has_option('ec2', 'all_instances'):\n",
"            self.all_instances = config.getboolean('ec2', 'all_instances')\n",
"        else:\n",
"            self.all_instances = False\n",
"        if config.has_option('ec2', 'all_rds_instances') and self.rds_enabled:\n",
"            self.all_rds_instances = config.getboolean('ec2', 'all_rds_instances')\n",
"        else:\n",
"            self.all_rds_instances = False\n",
"\n",
"        # Cache related\n",
"        cache_dir = os.path.expanduser(config.get('ec2', 'cache_path'))\n",
"        if not os.path.exists(cache_dir):\n",
"            os.makedirs(cache_dir)\n",
"\n",
"        self.cache_path_cache = cache_dir + \"/ansible-ec2.cache\"\n",
"        self.cache_path_index = cache_dir + \"/ansible-ec2.index\"\n",
"        self.cache_max_age = config.getint('ec2', 'cache_max_age')\n",
"\n",
"        # Configure nested groups instead of flat namespace.\n",
"        if config.has_option('ec2', 'nested_groups'):\n",
"            self.nested_groups = config.getboolean('ec2', 'nested_groups')\n",
"        else:\n",
"            self.nested_groups = False\n",
"\n",
"        # Configure which groups should be created.\n",
"        group_by_options = [\n",
"            'group_by_instance_id',\n",
"            'group_by_region',\n",
"            'group_by_availability_zone',\n",
"            'group_by_ami_id',\n",
"            'group_by_instance_type',\n",
"            'group_by_key_pair',\n",
"            'group_by_vpc_id',\n",
"            'group_by_security_group',\n",
"            'group_by_tag_keys',\n",
"            'group_by_tag_none',\n",
"            'group_by_route53_names',\n",
"            'group_by_rds_engine',\n",
"            'group_by_rds_parameter_group',\n",
"        ]\n",
"        for option in group_by_options:\n",
"            if config.has_option('ec2', option):\n",
"                setattr(self, option, config.getboolean('ec2', option))\n",
"            else:\n",
"                setattr(self, option, True)\n",
"\n",
"        # Do we need to just include hosts that match a pattern?\n",
"        try:\n",
"            pattern_include = config.get('ec2', 'pattern_include')\n",
"            if pattern_include and len(pattern_include) > 0:\n",
"                self.pattern_include = re.compile(pattern_include)\n",
"            else:\n",
"                self.pattern_include = None\n",
"        except ConfigParser.NoOptionError, e:\n",
"            self.pattern_include = None\n",
"\n",
"        # Do we need to exclude hosts that match a pattern?\n",
"        try:\n",
"            pattern_exclude = config.get('ec2', 'pattern_exclude');\n",
"            if pattern_exclude and len(pattern_exclude) > 0:\n",
"                self.pattern_exclude = re.compile(pattern_exclude)\n",
"            else:\n",
"                self.pattern_exclude = None\n",
"        except ConfigParser.NoOptionError, e:\n",
"            self.pattern_exclude = None\n",
"\n",
"        # Instance filters (see boto and EC2 API docs). Ignore invalid filters.\n",
"        self.ec2_instance_filters = defaultdict(list)\n",
"        if config.has_option('ec2', 'instance_filters'):\n",
"            for instance_filter in config.get('ec2', 'instance_filters', '').split(','):\n",
"                instance_filter = instance_filter.strip()\n",
"                if not instance_filter or '=' not in instance_filter:\n",
"                    continue\n",
"                filter_key, filter_value = [x.strip() for x in instance_filter.split('=', 1)]\n",
"                if not filter_key:\n",
"                    continue\n",
"                self.ec2_instance_filters[filter_key].append(filter_value)\n",
"\n",
"    def parse_cli_args(self):\n",
"        ''' Command line argument processing '''\n",
"\n",
"        parser = argparse.ArgumentParser(description='Produce an Ansible Inventory file based on EC2')\n",
"        parser.add_argument('--list', action='store_true', default=True,\n",
"                           help='List instances (default: True)')\n",
"        parser.add_argument('--host', action='store',\n",
"                           help='Get all the variables about a specific instance')\n",
"        parser.add_argument('--refresh-cache', action='store_true', default=False,\n",
"                           help='Force refresh of cache by making API requests to EC2 (default: False - use cache files)')\n",
"        self.args = parser.parse_args()\n",
"\n",
"\n",
"    def do_api_calls_update_cache(self):\n",
"        ''' Do API calls to each region, and save data in cache files '''\n",
"\n",
"        if self.route53_enabled:\n",
"            self.get_route53_records()\n",
"\n",
"        for region in self.regions:\n",
"            self.get_instances_by_region(region)\n",
"            if self.rds_enabled:\n",
"                self.get_rds_instances_by_region(region)\n",
"\n",
"        self.write_to_cache(self.inventory, self.cache_path_cache)\n",
"        self.write_to_cache(self.index, self.cache_path_index)\n",
"\n",
"    def connect(self, region):\n",
"        ''' create connection to api server'''\n",
"        if self.eucalyptus:\n",
"            conn = boto.connect_euca(host=self.eucalyptus_host)\n",
"            conn.APIVersion = '2010-08-31'\n",
"        else:\n",
"            conn = ec2.connect_to_region(region)\n",
"        # connect_to_region will fail \"silently\" by returning None if the region name is wrong or not supported\n",
"        if conn is None:\n",
"            self.fail_with_error(\"region name: %s likely not supported, or AWS is down.  connection to region failed.\" % region)\n",
"        return conn\n",
"\n",
"    def get_instances_by_region(self, region):\n",
"        ''' Makes an AWS EC2 API call to the list of instances in a particular\n",
"        region '''\n",
"\n",
"        try:\n",
"            conn = self.connect(region)\n",
"            reservations = []\n",
"            if self.ec2_instance_filters:\n",
"                for filter_key, filter_values in self.ec2_instance_filters.iteritems():\n",
"                    reservations.extend(conn.get_all_instances(filters = { filter_key : filter_values }))\n",
"            else:\n",
"                reservations = conn.get_all_instances()\n",
"\n",
"            for reservation in reservations:\n",
"                for instance in reservation.instances:\n",
"                    self.add_instance(instance, region)\n",
"\n",
"        except boto.exception.BotoServerError, e:\n",
"            if e.error_code == 'AuthFailure':\n",
"                error = self.get_auth_error_message()\n",
"            else:\n",
"                backend = 'Eucalyptus' if self.eucalyptus else 'AWS'\n",
"                error = \"Error connecting to %s backend.\\n%s\" % (backend, e.message)\n",
"            self.fail_with_error(error)\n",
"\n",
"    def get_rds_instances_by_region(self, region):\n",
"        ''' Makes an AWS API call to the list of RDS instances in a particular\n",
"        region '''\n",
"\n",
"        try:\n",
"            conn = rds.connect_to_region(region)\n",
"            if conn:\n",
"                instances = conn.get_all_dbinstances()\n",
"                for instance in instances:\n",
"                    self.add_rds_instance(instance, region)\n",
"        except boto.exception.BotoServerError, e:\n",
"            if e.error_code == 'AuthFailure':\n",
"                error = self.get_auth_error_message()\n",
"            if not e.reason == \"Forbidden\":\n",
"                error = \"Looks like AWS RDS is down:\\n%s\" % e.message\n",
"            self.fail_with_error(error)\n",
"\n",
"    def get_auth_error_message(self):\n",
"        ''' create an informative error message if there is an issue authenticating'''\n",
"        errors = [\"Authentication error retrieving ec2 inventory.\"]\n",
"        if None in [os.environ.get('AWS_ACCESS_KEY_ID'), os.environ.get('AWS_SECRET_ACCESS_KEY')]:\n",
"            errors.append(' - No AWS_ACCESS_KEY_ID or AWS_SECRET_ACCESS_KEY environment vars found')\n",
"        else:\n",
"            errors.append(' - AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY environment vars found but may not be correct')\n",
"\n",
"        boto_paths = ['/etc/boto.cfg', '~/.boto', '~/.aws/credentials']\n",
"        boto_config_found = list(p for p in boto_paths if os.path.isfile(os.path.expanduser(p)))\n",
"        if len(boto_config_found) > 0:\n",
"            errors.append(\" - Boto configs found at '%s', but the credentials contained may not be correct\" % ', '.join(boto_config_found))\n",
"        else:\n",
"            errors.append(\" - No Boto config found at any expected location '%s'\" % ', '.join(boto_paths))\n",
"\n",
"        return '\\n'.join(errors)\n",
"\n",
"    def fail_with_error(self, err_msg):\n",
"        '''log an error to std err for ansible-playbook to consume and exit'''\n",
"        sys.stderr.write(err_msg)\n",
"        sys.exit(1)\n",
"\n",
"    def get_instance(self, region, instance_id):\n",
"        conn = self.connect(region)\n",
"\n",
"        reservations = conn.get_all_instances([instance_id])\n",
"        for reservation in reservations:\n",
"            for instance in reservation.instances:\n",
"                return instance\n",
"\n",
"    def add_instance(self, instance, region):\n",
"        ''' Adds an instance to the inventory and index, as long as it is\n",
"        addressable '''\n",
"\n",
"        # Only want running instances unless all_instances is True\n",
"        if not self.all_instances and instance.state != 'running':\n",
"            return\n",
"\n",
"        # Select the best destination address\n",
"        if instance.subnet_id:\n",
"            dest = getattr(instance, self.vpc_destination_variable, None)\n",
"            if dest is None:\n",
"                dest = getattr(instance, 'tags').get(self.vpc_destination_variable, None)\n",
"        else:\n",
"            dest = getattr(instance, self.destination_variable, None)\n",
"            if dest is None:\n",
"                dest = getattr(instance, 'tags').get(self.destination_variable, None)\n",
"\n",
"        if not dest:\n",
"            # Skip instances we cannot address (e.g. private VPC subnet)\n",
"            return\n",
"\n",
"        # if we only want to include hosts that match a pattern, skip those that don't\n",
"        if self.pattern_include and not self.pattern_include.match(dest):\n",
"            return\n",
"\n",
"        # if we need to exclude hosts that match a pattern, skip those\n",
"        if self.pattern_exclude and self.pattern_exclude.match(dest):\n",
"            return\n",
"\n",
"        # Add to index\n",
"        self.index[dest] = [region, instance.id]\n",
"\n",
"        # Inventory: Group by instance ID (always a group of 1)\n",
"        if self.group_by_instance_id:\n",
"            self.inventory[instance.id] = [dest]\n",
"            if self.nested_groups:\n",
"                self.push_group(self.inventory, 'instances', instance.id)\n",
"\n",
"        # Inventory: Group by region\n",
"        if self.group_by_region:\n",
"            self.push(self.inventory, region, dest)\n",
"            if self.nested_groups:\n",
"                self.push_group(self.inventory, 'regions', region)\n",
"\n",
"        # Inventory: Group by availability zone\n",
"        if self.group_by_availability_zone:\n",
"            self.push(self.inventory, instance.placement, dest)\n",
"            if self.nested_groups:\n",
"                if self.group_by_region:\n",
"                    self.push_group(self.inventory, region, instance.placement)\n",
"                self.push_group(self.inventory, 'zones', instance.placement)\n",
"\n",
"        # Inventory: Group by Amazon Machine Image (AMI) ID\n",
"        if self.group_by_ami_id:\n",
"            ami_id = self.to_safe(instance.image_id)\n",
"            self.push(self.inventory, ami_id, dest)\n",
"            if self.nested_groups:\n",
"                self.push_group(self.inventory, 'images', ami_id)\n",
"\n",
"        # Inventory: Group by instance type\n",
"        if self.group_by_instance_type:\n",
"            type_name = self.to_safe('type_' + instance.instance_type)\n",
"            self.push(self.inventory, type_name, dest)\n",
"            if self.nested_groups:\n",
"                self.push_group(self.inventory, 'types', type_name)\n",
"\n",
"        # Inventory: Group by key pair\n",
"        if self.group_by_key_pair and instance.key_name:\n",
"            key_name = self.to_safe('key_' + instance.key_name)\n",
"            self.push(self.inventory, key_name, dest)\n",
"            if self.nested_groups:\n",
"                self.push_group(self.inventory, 'keys', key_name)\n",
"\n",
"        # Inventory: Group by VPC\n",
"        if self.group_by_vpc_id and instance.vpc_id:\n",
"            vpc_id_name = self.to_safe('vpc_id_' + instance.vpc_id)\n",
"            self.push(self.inventory, vpc_id_name, dest)\n",
"            if self.nested_groups:\n",
"                self.push_group(self.inventory, 'vpcs', vpc_id_name)\n",
"\n",
"        # Inventory: Group by security group\n",
"        if self.group_by_security_group:\n",
"            try:\n",
"                for group in instance.groups:\n",
"                    key = self.to_safe(\"security_group_\" + group.name)\n",
"                    self.push(self.inventory, key, dest)\n",
"                    if self.nested_groups:\n",
"                        self.push_group(self.inventory, 'security_groups', key)\n",
"            except AttributeError:\n",
"                self.fail_with_error('\\n'.join(['Package boto seems a bit older.',\n",
"                                            'Please upgrade boto >= 2.3.0.']))\n",
"\n",
"        # Inventory: Group by tag keys\n",
"        if self.group_by_tag_keys:\n",
"            for k, v in instance.tags.iteritems():\n",
"                key = self.to_safe(\"tag_\" + k + \"=\" + v)\n",
"                self.push(self.inventory, key, dest)\n",
"                if self.nested_groups:\n",
"                    self.push_group(self.inventory, 'tags', self.to_safe(\"tag_\" + k))\n",
"                    self.push_group(self.inventory, self.to_safe(\"tag_\" + k), key)\n",
"\n",
"        # Inventory: Group by Route53 domain names if enabled\n",
"        if self.route53_enabled and self.group_by_route53_names:\n",
"            route53_names = self.get_instance_route53_names(instance)\n",
"            for name in route53_names:\n",
"                self.push(self.inventory, name, dest)\n",
"                if self.nested_groups:\n",
"                    self.push_group(self.inventory, 'route53', name)\n",
"\n",
"        # Global Tag: instances without tags\n",
"        if self.group_by_tag_none and len(instance.tags) == 0:\n",
"            self.push(self.inventory, 'tag_none', dest)\n",
"            if self.nested_groups:\n",
"                self.push_group(self.inventory, 'tags', 'tag_none')\n",
"\n",
"        # Global Tag: tag all EC2 instances\n",
"        self.push(self.inventory, 'ec2', dest)\n",
"\n",
"        self.inventory[\"_meta\"][\"hostvars\"][dest] = self.get_host_info_dict_from_instance(instance)\n",
"\n",
"\n",
"    def add_rds_instance(self, instance, region):\n",
"        ''' Adds an RDS instance to the inventory and index, as long as it is\n",
"        addressable '''\n",
"\n",
"        # Only want available instances unless all_rds_instances is True\n",
"        if not self.all_rds_instances and instance.status != 'available':\n",
"            return\n",
"\n",
"        # Select the best destination address\n",
"        dest = instance.endpoint[0]\n",
"\n",
"        if not dest:\n",
"            # Skip instances we cannot address (e.g. private VPC subnet)\n",
"            return\n",
"\n",
"        # Add to index\n",
"        self.index[dest] = [region, instance.id]\n",
"\n",
"        # Inventory: Group by instance ID (always a group of 1)\n",
"        if self.group_by_instance_id:\n",
"            self.inventory[instance.id] = [dest]\n",
"            if self.nested_groups:\n",
"                self.push_group(self.inventory, 'instances', instance.id)\n",
"\n",
"        # Inventory: Group by region\n",
"        if self.group_by_region:\n",
"            self.push(self.inventory, region, dest)\n",
"            if self.nested_groups:\n",
"                self.push_group(self.inventory, 'regions', region)\n",
"\n",
"        # Inventory: Group by availability zone\n",
"        if self.group_by_availability_zone:\n",
"            self.push(self.inventory, instance.availability_zone, dest)\n",
"            if self.nested_groups:\n",
"                if self.group_by_region:\n",
"                    self.push_group(self.inventory, region, instance.availability_zone)\n",
"                self.push_group(self.inventory, 'zones', instance.availability_zone)\n",
"\n",
"        # Inventory: Group by instance type\n",
"        if self.group_by_instance_type:\n",
"            type_name = self.to_safe('type_' + instance.instance_class)\n",
"            self.push(self.inventory, type_name, dest)\n",
"            if self.nested_groups:\n",
"                self.push_group(self.inventory, 'types', type_name)\n",
"\n",
"        # Inventory: Group by VPC\n",
"        if self.group_by_vpc_id and instance.subnet_group and instance.subnet_group.vpc_id:\n",
"            vpc_id_name = self.to_safe('vpc_id_' + instance.subnet_group.vpc_id)\n",
"            self.push(self.inventory, vpc_id_name, dest)\n",
"            if self.nested_groups:\n",
"                self.push_group(self.inventory, 'vpcs', vpc_id_name)\n",
"\n",
"        # Inventory: Group by security group\n",
"        if self.group_by_security_group:\n",
"            try:\n",
"                if instance.security_group:\n",
"                    key = self.to_safe(\"security_group_\" + instance.security_group.name)\n",
"                    self.push(self.inventory, key, dest)\n",
"                    if self.nested_groups:\n",
"                        self.push_group(self.inventory, 'security_groups', key)\n",
"\n",
"            except AttributeError:\n",
"                self.fail_with_error('\\n'.join(['Package boto seems a bit older.',\n",
"                                            'Please upgrade boto >= 2.3.0.']))\n",
"\n",
"\n",
"        # Inventory: Group by engine\n",
"        if self.group_by_rds_engine:\n",
"            self.push(self.inventory, self.to_safe(\"rds_\" + instance.engine), dest)\n",
"            if self.nested_groups:\n",
"                self.push_group(self.inventory, 'rds_engines', self.to_safe(\"rds_\" + instance.engine))\n",
"\n",
"        # Inventory: Group by parameter group\n",
"        if self.group_by_rds_parameter_group:\n",
"            self.push(self.inventory, self.to_safe(\"rds_parameter_group_\" + instance.parameter_group.name), dest)\n",
"            if self.nested_groups:\n",
"                self.push_group(self.inventory, 'rds_parameter_groups', self.to_safe(\"rds_parameter_group_\" + instance.parameter_group.name))\n",
"\n",
"        # Global Tag: all RDS instances\n",
"        self.push(self.inventory, 'rds', dest)\n",
"\n",
"        self.inventory[\"_meta\"][\"hostvars\"][dest] = self.get_host_info_dict_from_instance(instance)\n",
"\n",
"\n",
"    def get_route53_records(self):\n",
"        ''' Get and store the map of resource records to domain names that\n",
"        point to them. '''\n",
"\n",
"        r53_conn = route53.Route53Connection()\n",
"        all_zones = r53_conn.get_zones()\n",
"\n",
"        route53_zones = [ zone for zone in all_zones if zone.name[:-1]\n",
"                          not in self.route53_excluded_zones ]\n",
"\n",
"        self.route53_records = {}\n",
"\n",
"        for zone in route53_zones:\n",
"            rrsets = r53_conn.get_all_rrsets(zone.id)\n",
"\n",
"            for record_set in rrsets:\n",
"                record_name = record_set.name\n",
"\n",
"                if record_name.endswith('.'):\n",
"                    record_name = record_name[:-1]\n",
"\n",
"                for resource in record_set.resource_records:\n",
"                    self.route53_records.setdefault(resource, set())\n",
"                    self.route53_records[resource].add(record_name)\n",
"\n",
"\n",
"    def get_instance_route53_names(self, instance):\n",
"        ''' Check if an instance is referenced in the records we have from\n",
"        Route53. If it is, return the list of domain names pointing to said\n",
"        instance. If nothing points to it, return an empty list. '''\n",
"\n",
"        instance_attributes = [ 'public_dns_name', 'private_dns_name',\n",
"                                'ip_address', 'private_ip_address' ]\n",
"\n",
"        name_list = set()\n",
"\n",
"        for attrib in instance_attributes:\n",
"            try:\n",
"                value = getattr(instance, attrib)\n",
"            except AttributeError:\n",
"                continue\n",
"\n",
"            if value in self.route53_records:\n",
"                name_list.update(self.route53_records[value])\n",
"\n",
"        return list(name_list)\n",
"\n",
"\n",
"    def get_host_info_dict_from_instance(self, instance):\n",
"        instance_vars = {}\n",
"        for key in vars(instance):\n",
"            value = getattr(instance, key)\n",
"            key = self.to_safe('ec2_' + key)\n",
"\n",
"            # Handle complex types\n",
"            # state/previous_state changed to properties in boto in https://github.com/boto/boto/commit/a23c379837f698212252720d2af8dec0325c9518\n",
"            if key == 'ec2__state':\n",
"                instance_vars['ec2_state'] = instance.state or ''\n",
"                instance_vars['ec2_state_code'] = instance.state_code\n",
"            elif key == 'ec2__previous_state':\n",
"                instance_vars['ec2_previous_state'] = instance.previous_state or ''\n",
"                instance_vars['ec2_previous_state_code'] = instance.previous_state_code\n",
"            elif type(value) in [int, bool]:\n",
"                instance_vars[key] = value\n",
"            elif type(value) in [str, unicode]:\n",
"                instance_vars[key] = value.strip()\n",
"            elif type(value) == type(None):\n",
"                instance_vars[key] = ''\n",
"            elif key == 'ec2_region':\n",
"                instance_vars[key] = value.name\n",
"            elif key == 'ec2__placement':\n",
"                instance_vars['ec2_placement'] = value.zone\n",
"            elif key == 'ec2_tags':\n",
"                for k, v in value.iteritems():\n",
"                    key = self.to_safe('ec2_tag_' + k)\n",
"                    instance_vars[key] = v\n",
"            elif key == 'ec2_groups':\n",
"                group_ids = []\n",
"                group_names = []\n",
"                for group in value:\n",
"                    group_ids.append(group.id)\n",
"                    group_names.append(group.name)\n",
"                instance_vars[\"ec2_security_group_ids\"] = ','.join([str(i) for i in group_ids])\n",
"                instance_vars[\"ec2_security_group_names\"] = ','.join([str(i) for i in group_names])\n",
"            else:\n",
"                pass\n",
"                # TODO Product codes if someone finds them useful\n",
"                #print key\n",
"                #print type(value)\n",
"                #print value\n",
"\n",
"        return instance_vars\n",
"\n",
"    def get_host_info(self):\n",
"        ''' Get variables about a specific host '''\n",
"\n",
"        if len(self.index) == 0:\n",
"            # Need to load index from cache\n",
"            self.load_index_from_cache()\n",
"\n",
"        if not self.args.host in self.index:\n",
"            # try updating the cache\n",
"            self.do_api_calls_update_cache()\n",
"            if not self.args.host in self.index:\n",
"                # host might not exist anymore\n",
"                return self.json_format_dict({}, True)\n",
"\n",
"        (region, instance_id) = self.index[self.args.host]\n",
"\n",
"        instance = self.get_instance(region, instance_id)\n",
"        return self.json_format_dict(self.get_host_info_dict_from_instance(instance), True)\n",
"\n",
"    def push(self, my_dict, key, element):\n",
"        ''' Push an element onto an array that may not have been defined in\n",
"        the dict '''\n",
"        group_info = my_dict.setdefault(key, [])\n",
"        if isinstance(group_info, dict):\n",
"            host_list = group_info.setdefault('hosts', [])\n",
"            host_list.append(element)\n",
"        else:\n",
"            group_info.append(element)\n",
"\n",
"    def push_group(self, my_dict, key, element):\n",
"        ''' Push a group as a child of another group. '''\n",
"        parent_group = my_dict.setdefault(key, {})\n",
"        if not isinstance(parent_group, dict):\n",
"            parent_group = my_dict[key] = {'hosts': parent_group}\n",
"        child_groups = parent_group.setdefault('children', [])\n",
"        if element not in child_groups:\n",
"            child_groups.append(element)\n",
"\n",
"    def get_inventory_from_cache(self):\n",
"        ''' Reads the inventory from the cache file and returns it as a JSON\n",
"        object '''\n",
"\n",
"        cache = open(self.cache_path_cache, 'r')\n",
"        json_inventory = cache.read()\n",
"        return json_inventory\n",
"\n",
"\n",
"    def load_index_from_cache(self):\n",
"        ''' Reads the index from the cache file sets self.index '''\n",
"\n",
"        cache = open(self.cache_path_index, 'r')\n",
"        json_index = cache.read()\n",
"        self.index = json.loads(json_index)\n",
"\n",
"\n",
"    def write_to_cache(self, data, filename):\n",
"        ''' Writes data in JSON format to a file '''\n",
"\n",
"        json_data = self.json_format_dict(data, True)\n",
"        cache = open(filename, 'w')\n",
"        cache.write(json_data)\n",
"        cache.close()\n",
"\n",
"\n",
"    def to_safe(self, word):\n",
"        ''' Converts 'bad' characters in a string to underscores so they can be\n",
"        used as Ansible groups '''\n",
"\n",
"        return re.sub(\"[^A-Za-z0-9\\-]\", \"_\", word)\n",
"\n",
"\n",
"    def json_format_dict(self, data, pretty=False):\n",
"        ''' Converts a dict to a JSON object and dumps it as a formatted\n",
"        string '''\n",
"\n",
"        if pretty:\n",
"            return json.dumps(data, sort_keys=True, indent=2)\n",
"        else:\n",
"            return json.dumps(data)\n",
"\n",
"\n",
"# Run the script\n",
"Ec2Inventory()\n",
                  ])
    mode "000755"
  end

end